<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/iron-dropdown/iron-dropdown.html">
<link rel="import" href="../../bower_components/paper-menu/paper-menu.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/paper-item/paper-icon-item.html">

<link rel="import" href="../node/node.html">
<link rel="import" href="../connector/connector.html">
<link rel="import" href="../set/set.html">

<link rel="import" href="surface-styles.html">

<dom-module id="yb-surface">

  <style include="surface-styles"></style>

  <template>
  
    <div id="background" on-mousedown="backgroundMousedown"></div>
    <div id="boxSelection" class="hidden"></div>
    
    <iron-dropdown id="backgroundDropdown" horizontal-align="left" vertical-align="top">
      <div class="dropdown-content">
        <paper-menu>
          <paper-icon-item on-tap="menuItem_CreateNode">
            <iron-icon icon="icons:add" item-icon></iron-icon>
            Add Node
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_CreateSet">
            <iron-icon icon="icons:add" item-icon></iron-icon>
            Add Set
          </paper-icon-item>
        </paper-menu>
      </div>
    </iron-dropdown>
    
    <iron-dropdown id="selectionDropdown" horizontal-align="left" vertical-align="top">
      <div class="dropdown-content">
        <paper-menu>
          <paper-icon-item on-tap="menuItem_CopySelected">
            <iron-icon icon="icons:content-copy" item-icon></iron-icon>
            Copy
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_RevealLinks">
            <iron-icon icon="icons:visibility" item-icon></iron-icon>
            Reveal Links
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_HideLinks">
            <iron-icon icon="icons:visibility-off" item-icon></iron-icon>
            Hide Links
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_HideSelected">
            <iron-icon icon="icons:visibility-off" item-icon></iron-icon>
            Hide
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_DeleteSelected">
            <iron-icon icon="icons:delete" item-icon></iron-icon>
            Delete
          </paper-icon-item>
        </paper-menu>
      </div>
    </iron-dropdown>
  </template>
  
  <script>
    (function() {
      'use strict';
      
      Polymer({
        is: 'yb-surface',
        created: function() {
          var self = this;
          
          self.nodeWidgets = [];
          
          self.connectors = new Set();
          self.connectorsFrom = new Map();
          self.connectorsVia  = new Map();
          self.connectorsTo   = new Map();
          
          self.draggingConnectors = [];
          
          self.selectedNodeWidgets = new Set();
          self.selectedConnectors  = new Set();
          self.selectedSetWidgets  = new Set();
          
          self.setWidgets = new Set();
          
          require(['client', 'node_id'], function(client, node_id) {
            self.client  = client;
            self.node_id = node_id;
          });
        },
        ready: function() {
        
          var self = this;
        
          require(['client', 'node_id'], function(client, node_id) {
            self.client  = client;
            self.node_id = node_id;
        
            self.createNodeWidget({x: 100, y: 40},  '52f9cf0e223d559931856acc98400f21');
            self.createNodeWidget({x: 100, y: 100}, '1264ed87a8274e5188f9020954811805');
            self.createNodeWidget({x: 100, y: 160}, '5c4d67cf88fd9c5dbc841dee378b6b4b');
            self.createNodeWidget({x: 185, y: 160}, '7e1b27583610201f8b48941d3637b13f');
            
            self.createSetWidget({x: 400, y: 50});
          });
        },
        listeners: {
          contextmenu: 'oncontextmenu'
        },
        captureMouse: function(cursor, retargetAllEvents) {
        
          this.cusorBeforeMouseCapture = document.body.style.cursor;
          document.body.style.cursor = cursor;
          
          if (retargetAllEvents) {
            if (this.setCapture) {
              this.setCapture(retargetAllEvents);
            } else {
              this.pointerBlocker = document.createElement('div');
              this.pointerBlocker.classList.add('pointer-blocker');
              this.pointerBlocker.style.position = 'fixed';
              this.pointerBlocker.style.left   = '0';
              this.pointerBlocker.style.top    = '0';
              this.pointerBlocker.style.right  = '0';
              this.pointerBlocker.style.bottom = '0';
              this.pointerBlocker.style['z-index'] = '1000';
              this.pointerBlocker.style['pointer-events'] = 'all';
              document.body.appendChild(this.pointerBlocker);
            }
          }
        },
        releaseMouse: function() {
          
          document.body.style.cursor = this.cusorBeforeMouseCapture;
        
          if (document.releaseCapture) {
            document.releaseCapture();
          } else {
            if (this.pointerBlocker) {
              document.body.removeChild(this.pointerBlocker);
              this.pointerBlocker = null;
            }
          }
        },
        oncontextmenu: function(event) {
          event.preventDefault();
          return false;
        },
        getSelectors: function() {
          var selectors = [];
          this.setWidgets.forEach(function(setWidget) {
            selectors = selectors.concat(setWidget.selectors);
          });
          return selectors;
        },
        backgroundMousedown: function(event) {
          if (this.$.selectionDropdown.opened) {
            this.$.selectionDropdown.close();
          }
          
          if (!event.ctrlKey) {
            this.deselect();
          }
        
          if (event.button === 0) {
            if (this.$.backgroundDropdown.opened) {
              this.$.backgroundDropdown.close();
            }
            return this.startBoxSelection(event);
          } else if (event.button === 2) {
            event.preventDefault();
            this.lastMenuPosition = {
              x: event.offsetX,
              y: event.offsetY,
            }
            this.$.backgroundDropdown.set('horizontalOffset', event.offsetX);
            this.$.backgroundDropdown.set('verticalOffset',   event.offsetY);
            if (!this.$.backgroundDropdown.opened) {
              this.$.backgroundDropdown.open();
            }
            return false;
          }
        },
        startBoxSelection: function(event) {
        
          event.preventDefault();
        
          var self = this;
          
          self.captureMouse('crosshair', true);
          
          var dragStartOffset = {
            x: event.offsetX,
            y: event.offsetY,
          }
          var dragStartPage = {
            x: event.pageX,
            y: event.pageY,
          }
          
          self.$.boxSelection.style.left = dragStartOffset.x + 'px';
          self.$.boxSelection.style.top  = dragStartOffset.y + 'px';
          self.$.boxSelection.style.width  = '0px';
          self.$.boxSelection.style.height = '0px';
          
          self.$.boxSelection.classList.remove('hidden');
          
          var alreadySelectedNodeWidgets = new Set(self.selectedNodeWidgets);
          var alreadySelectedSetWidgets  = new Set(self.selectedSetWidgets);
          
          function handleMousemove(event) {
          
            var dragDelta = {
              x: event.pageX - dragStartPage.x,
              y: event.pageY - dragStartPage.y,
            }
          
            var currentSelectionRect = {
              left:   Math.min(dragStartOffset.x, dragStartOffset.x + dragDelta.x),
              top:    Math.min(dragStartOffset.y, dragStartOffset.y + dragDelta.y),
              right:  Math.max(dragStartOffset.x, dragStartOffset.x + dragDelta.x),
              bottom: Math.max(dragStartOffset.y, dragStartOffset.y + dragDelta.y),
            }
            
            var surfaceRect = self.getBoundingClientRect();
            
            self.$.boxSelection.style.left   = currentSelectionRect.left + 'px';
            self.$.boxSelection.style.top    = currentSelectionRect.top  + 'px';
            self.$.boxSelection.style.width  = (currentSelectionRect.right  - currentSelectionRect.left) + 'px';
            self.$.boxSelection.style.height = (currentSelectionRect.bottom - currentSelectionRect.top)  + 'px';
            
            var nodesToSelect = new Set(self.getNodesInRect(currentSelectionRect));
            alreadySelectedNodeWidgets.forEach(function(nodeWidget) {
              nodesToSelect.add(nodeWidget);
            });
            self.selectNodeWidgets(nodesToSelect);
            
            var setWidgetsToSelect = new Set(self.getSetWidgetsInRect(currentSelectionRect));
            alreadySelectedSetWidgets.forEach(function(nodeWidget) {
              setWidgetsToSelect.add(nodeWidget);
            });
            self.selectSetWidgets(setWidgetsToSelect);
          }
          function handleMouseup(event) {
          
            self.$.boxSelection.classList.add('hidden');
            
            self.releaseMouse();
            
            window.removeEventListener('mousemove', handleMousemove);
            window.removeEventListener('mouseup',   handleMouseup);
          }
          
          window.addEventListener('mousemove', handleMousemove);
          window.addEventListener('mouseup',   handleMouseup);
          
          return false;
        },
        getNodesInRect: function(rect) {
          return this.nodeWidgets.filter(function(nodeWidget) {
            var nodeClientRect = nodeWidget.getBoundingClientRect();
            var nodeRect = {
              left:   nodeWidget.position.x,
              top:    nodeWidget.position.y,
              right:  nodeWidget.position.x + nodeClientRect.width,
              bottom: nodeWidget.position.y + nodeClientRect.height,
            }
            return !(nodeRect.left > rect.right  || nodeRect.right  < rect.left ||
                     nodeRect.top  > rect.bottom || nodeRect.bottom < rect.top);
          });
        },
        getSetWidgetsInRect: function(rect) {
          return Array.from(this.setWidgets).filter(function(setWidget) {
            var setClientRect = setWidget.getBoundingClientRect();
            var setRect = {
              left:   setWidget.position.x,
              top:    setWidget.position.y,
              right:  setWidget.position.x + setClientRect.width,
              bottom: setWidget.position.y + setClientRect.height,
            }
            return !(setRect.left > rect.right  || setRect.right  < rect.left ||
                     setRect.top  > rect.bottom || setRect.bottom < rect.top);
          });
        },
        startDraggingSelected: function(event) {
        
          var self = this;
          
          if (event.detail.shiftKey) {
            self.copySelected();
          }
        
          var surfaceRect = self.getBoundingClientRect();
          
          var cursorStartPos = {
            x: event.detail.pageX,
            y: event.detail.pageY,
          }
          
          self.selectedNodeWidgets.forEach(function(nodeWidget) {
            nodeWidget.dragStartPosition = nodeWidget.position;
            nodeWidget.style['pointer-events'] = 'none';
          });
          
          self.selectedSetWidgets.forEach(function(setWidget) {
            setWidget.dragStartPosition = setWidget.position;
          });
          
          document.body.style.cursor = '-webkit-grabbing';
          
          function handleMousemove(event) {
          
            var cursorOffset = {
              x: event.pageX - cursorStartPos.x,
              y: event.pageY - cursorStartPos.y,
            }
            
            self.selectedNodeWidgets.forEach(function(selectedNodeWidget) {
            
              var newPos = {
                x: selectedNodeWidget.dragStartPosition.x + cursorOffset.x,
                y: selectedNodeWidget.dragStartPosition.y + cursorOffset.y,
              }
          
              selectedNodeWidget.style.left = newPos.x + 'px';
              selectedNodeWidget.style.top  = newPos.y + 'px';
              selectedNodeWidget.position = newPos;
            
              self.updateConnectorsForNodeWidget(selectedNodeWidget);
            });
            
            self.selectedSetWidgets.forEach(function(selectedSetWidget) {
              
              var newPos = {
                x: selectedSetWidget.dragStartPosition.x + cursorOffset.x,
                y: selectedSetWidget.dragStartPosition.y + cursorOffset.y,
              }
              
              selectedSetWidget.style.left = newPos.x + 'px';
              selectedSetWidget.style.top  = newPos.y + 'px';
              selectedSetWidget.position = newPos;
            });
          }
          
          function finishDragging() {
            window.removeEventListener('mousemove', handleMousemove);
            window.removeEventListener('mouseup',   finishDragging);
            document.body.style.cursor = 'auto';
            self.selectedNodeWidgets.forEach(function(nodeWidget) {
              nodeWidget.style['pointer-events'] = 'auto';
            });
            
            self.getSelectors().forEach(function(selector) {
              selector.removeEventListener('mouseover', selectorMouseover);
              selector.removeEventListener('mouseout',  selectorMouseout);
              selector.removeEventListener('mouseup',   selectorMouseup);
              selector.classList.remove('drag-ready');
            });
          }
          
          window.addEventListener('mousemove', handleMousemove);
          window.addEventListener('mouseup',   finishDragging);
          
          function selectorMouseover(event) {
            var selector = event.currentTarget;
            selector.classList.add('drag-hover');
          }
          function selectorMouseout(event) {
            var selector = event.currentTarget;
            selector.classList.remove('drag-hover');
          }
          function selectorMouseup(event) {
            var selector = event.currentTarget;
            selector.classList.remove('drag-hover');
            var primaryNodeWidget = null;
            if (self.selectedNodeWidgets.size === 1) {
              self.selectedNodeWidgets.forEach(function(nodeWidget) {
                primaryNodeWidget = nodeWidget;
              });
            }
            if (primaryNodeWidget) {
              selector.set('nodeId', primaryNodeWidget.nodeId);
            }
            self.selectedNodeWidgets.forEach(function(nodeWidget) {
              nodeWidget.style.left = nodeWidget.dragStartPosition.x + 'px';
              nodeWidget.style.top  = nodeWidget.dragStartPosition.y + 'px';
              nodeWidget.position   = nodeWidget.dragStartPosition;
              self.updateConnectorsForNodeWidget(nodeWidget);
            });
            this.updateStyles();
            finishDragging();
          }
          
          if (self.selectedNodeWidgets.size === 1) {
            self.getSelectors().forEach(function(selector) {
              selector.addEventListener('mouseover', selectorMouseover);
              selector.addEventListener('mouseout',  selectorMouseout);
              selector.addEventListener('mouseup',   selectorMouseup);
              selector.classList.add('drag-ready');
            });
          }
        },
        createNodeWidget: function(position, id) {
        
          var self = this;
        
          var nodeWidget = document.createElement('yb-node');
          if (!id) {
            id = self.node_id.makeHex();
          }
          nodeWidget.nodeId = id;
          nodeWidget.style.position = 'absolute';
          nodeWidget.style.left = position.x + 'px';
          nodeWidget.style.top  = position.y + 'px';
          nodeWidget.position = position;
          
          nodeWidget.addEventListener('dimensionsChanged', function(event) {
            self.updateConnectorsForNodeWidget(nodeWidget);
          });
          
          self._setupNodeWidgetHighlighting(nodeWidget);
          self._setupNodeWidgetSelection(nodeWidget);
          self._setupNodeWidgetDragging(nodeWidget);
          self._setupNodeWidgetConnectorDragging(nodeWidget);
          self._setupNodeWidgetMenu(nodeWidget);
          
          Polymer.dom(self.root).appendChild(nodeWidget);
          
          self.nodeWidgets.push(nodeWidget);
          
          return nodeWidget;
        },
        _setupNodeWidgetHighlighting: function(nodeWidget) {
          var self = this;
          nodeWidget.addEventListener('mouseover', function(event) {
            var nodeCopies = [];
            self.nodeWidgets.forEach(function(otherNodeWidget) {
              if (otherNodeWidget !== nodeWidget && otherNodeWidget.nodeId === nodeWidget.nodeId) {
                nodeCopies.push(otherNodeWidget);
                otherNodeWidget.set('highlighted', true);
              }
            });
            function handleMouseout() {
              nodeWidget.removeEventListener('mouseout', handleMouseout);
              nodeCopies.forEach(function(nodeWidgetCopy) {
                nodeWidgetCopy.set('highlighted', false);
              });
            }
            nodeWidget.addEventListener('mouseout', handleMouseout);
          });
        },
        _setupNodeWidgetSelection: function(nodeWidget) {
          var self = this;
          nodeWidget.addEventListener('selected', function(event) {
            if (!self.selectedNodeWidgets.has(nodeWidget)) {
              if (!event.detail.ctrlKey) {
                self.deselect();
              }
              self.selectedNodeWidgets.add(nodeWidget);
              nodeWidget.set('selected', true);
            }
          });
        },
        selectNodeWidgets: function(nodeWidgets) {
          this.selectedNodeWidgets.forEach(function(nodeWidget) {
            if (!nodeWidgets.has(nodeWidget)) {
              nodeWidget.set('selected', false);
            }
          });
          
          nodeWidgets.forEach(function(nodeWidget) {
            nodeWidget.set('selected', true);
          });
          
          this.selectedNodeWidgets = new Set(nodeWidgets);
        },
        selectSetWidgets: function(setWidgets) {
          this.selectedSetWidgets.forEach(function(setWidget) {
            if (!setWidgets.has(setWidget)) {
              setWidget.set('selected', false);
            }
          });
          
          setWidgets.forEach(function(setWidget) {
            setWidget.set('selected', true);
          });
          
          this.selectedSetWidgets = new Set(setWidgets);
        },
        deselect: function() {
          this.selectedNodeWidgets.forEach(function(nodeWidget) {
            nodeWidget.set('selected', false);
          });
          this.selectedNodeWidgets.clear();
          
          this.selectedConnectors.forEach(function(connector) {
            connector.set('selected', false);
          });
          this.selectedConnectors.clear();
          
          this.selectedSetWidgets.forEach(function(setWidget) {
            setWidget.set('selected', false);
          });
          this.selectedSetWidgets.clear();
        },
        removeSelectedWidgets: function() {
          var self = this;
          
          var connectorsToDelete = new Set(self.selectedConnectors);
          
          self.selectedNodeWidgets.forEach(function(nodeWidget) {
            nodeWidget.connectors().forEach(function(connector) {
              connectorsToDelete.add(connector);
            });
            Polymer.dom(self.root).removeChild(nodeWidget);
          });
          self.nodeWidgets = self.nodeWidgets.filter(function(nodeWidget) {
            return !self.selectedNodeWidgets.has(nodeWidget);
          });
          self.selectedNodeWidgets.clear();
          
          connectorsToDelete.forEach(function(connector) {
            connector.fromWidget.connectorsFrom.delete(connector);
            connector.viaWidget.connectorsVia.delete(connector);
            connector.toWidget.connectorsTo.delete(connector);
            Polymer.dom(self.root).removeChild(connector);
          });
          
          var affectedLinks = new Set();
          
          self.selectedConnectors.forEach(function(connector) {
            affectedLinks.add(self.node_id.linkToKey({
              from: self.node_id.fromHex(connector.fromWidget.nodeId),
              via:  self.node_id.fromHex(connector.viaWidget.nodeId),
              to:   self.node_id.fromHex(connector.toWidget.nodeId)
            }));
          });
          self.connectors = new Set(Array.from(self.connectors.entries()).filter(function(connector) {
            return !connectorsToDelete.has(connector);
          }));
          self.selectedConnectors.clear();
          
          self.selectedSetWidgets.forEach(function(setWidget) {
            Polymer.dom(self.root).removeChild(setWidget);
            self.setWidgets.delete(setWidget);
          });
          self.selectedSetWidgets.clear();
          
          return affectedLinks;
        },
        removeConnector: function(connector) {
          connector.fromWidget.connectorsFrom.delete(connector);
          connector.viaWidget.connectorsVia.delete(connector);
          connector.toWidget.connectorsTo.delete(connector);
          Polymer.dom(this.root).removeChild(connector);
          this.connectors.delete(connector);
        },
        removeSelectedConnectors: function() {
          var self = this;
          self.selectedConnectors.forEach(function(connector) {
            connector.fromWidget.connectorsFrom.delete(connector);
            connector.viaWidget.connectorsVia.delete(connector);
            connector.toWidget.connectorsTo.delete(connector);
            Polymer.dom(self.root).removeChild(connector);
            self.connectors.delete(connector);
          });
          self.selectedConnectors.clear();
        },
        removeConnectorsBetweenSelectedNodeWidgets: function() {
          var self = this;
          self.connectors = new Set(Array.from(self.connectors).filter(function(connector) {
            if (self.selectedNodeWidgets.has(connector.fromWidget) &&
                self.selectedNodeWidgets.has(connector.viaWidget) &&
                self.selectedNodeWidgets.has(connector.toWidget)) {
              
              self.removeConnector(connector);
              return false;
            } else {
              return true;
            }
          }))
        },
        copySelected: function(offset) {
          var self = this;
          
          var newNodeWidgets = new Set();
          var newConnectors  = new Set();
          var newSetWidgets  = new Set();
          
          var oldToNewNodeWidgetMap = new Map();
          
          self.selectedNodeWidgets.forEach(function(nodeWidget) {
            var newPosition = {
              x: nodeWidget.position.x + (offset || 0),
              y: nodeWidget.position.y + (offset || 0),
            }
            var newNodeWidget = self.createNodeWidget(newPosition, nodeWidget.nodeId);
            newNodeWidgets.add(newNodeWidget);
            
            nodeWidget.set('selected', false);
            newNodeWidget.set('selected', true);
            
            oldToNewNodeWidgetMap.set(nodeWidget, newNodeWidget);
          });
          
          self.selectedConnectors.forEach(function(connector) {
            
            if (self.selectedNodeWidgets.has(connector.fromWidget) &&
                self.selectedNodeWidgets.has(connector.viaWidget) &&
                self.selectedNodeWidgets.has(connector.toWidget)) {
              
              var newConnector = self.createConnector(
                oldToNewNodeWidgetMap.get(connector.fromWidget),
                oldToNewNodeWidgetMap.get(connector.viaWidget),
                oldToNewNodeWidgetMap.get(connector.toWidget)
              );
              newConnectors.add(newConnector);
              
              connector.set('selected', false);
              newConnector.set('selected', true);
            }
          });
          
          self.selectedSetWidgets.forEach(function(setWidget) {
          
            var newPosition = {
              x: setWidget.position.x + (offset || 0),
              y: setWidget.position.y + (offset || 0),
            }
          
            var newSetWidget = self.createSetWidget(newPosition);
            newSetWidget.set('from', setWidget.from);
            newSetWidget.set('via',  setWidget.via);
            newSetWidget.set('to',   setWidget.to);
            
            newSetWidgets.add(newSetWidget);
            
            setWidget.set('selected', false);
            newSetWidget.set('selected', true);
          });
          
          self.selectedNodeWidgets = newNodeWidgets;
          self.selectedConnectors  = newConnectors;
          self.selectedSetWidgets  = newSetWidgets;
        },
        revealLinksInSelected: function() {
        
          var self = this;
          
          var selectedNodeIdsToWidgets = new Map();
          self.selectedNodeWidgets.forEach(function(nodeWidget) {
            var nodeIdKey = self.node_id.toMapKey(self.node_id.fromHex(nodeWidget.nodeId));
            if (selectedNodeIdsToWidgets.has(nodeIdKey)) {
              selectedNodeIdsToWidgets.get(nodeIdKey).add(nodeWidget);
            } else {
              selectedNodeIdsToWidgets.set(nodeIdKey, new Set([nodeWidget]));
            }
          });
          
          self.client.web.getLinks().forEach(function(link) {
            if (selectedNodeIdsToWidgets.has(self.node_id.toMapKey(link.from)) &&
                selectedNodeIdsToWidgets.has(self.node_id.toMapKey(link.via)) &&
                selectedNodeIdsToWidgets.has(self.node_id.toMapKey(link.to))) {
              
              var nodeWidgetsFrom = selectedNodeIdsToWidgets.get(self.node_id.toMapKey(link.from));
              var nodeWidgetsVia  = selectedNodeIdsToWidgets.get(self.node_id.toMapKey(link.via));
              var nodeWidgetsTo   = selectedNodeIdsToWidgets.get(self.node_id.toMapKey(link.to));
              
              nodeWidgetsFrom.forEach(function(nodeWidgetFrom) {
                nodeWidgetsVia.forEach(function(nodeWidgetVia) {
                  nodeWidgetsTo.forEach(function(nodeWidgetTo) {
                    
                    var alreadyHasConnector = Array.from(self.connectors).some(function(connector) {
                      return connector.fromWidget === nodeWidgetFrom &&
                             connector.viaWidget  === nodeWidgetVia &&
                             connector.toWidget   === nodeWidgetTo;
                    });
                  
                    if (!alreadyHasConnector) {
                      self.createConnector(nodeWidgetFrom, nodeWidgetVia, nodeWidgetTo);
                    }
                  });
                });
              });
            }
          });
        },
        _setupNodeWidgetDragging: function(nodeWidget) {
          var self = this;
          nodeWidget.addEventListener('dragStart', function(event) {
            self.startDraggingSelected(event);
          });
        },
        _setupNodeWidgetConnectorDragging: function(nodeWidget) {
        
          var self = this;
        
          nodeWidget.addEventListener('rightButtonDragStart', function(event) {
          
            var surfaceRect = self.getBoundingClientRect();
            
            self.draggingConnectorNodes = {
              from: new Set(self.selectedNodeWidgets),
              via:  null,
              to:   null,
            }
            self.draggingConnectorNodes.from.add(nodeWidget);
            
            self.draggingConnectors = [];
            self.draggingConnectorNodes.from.forEach(function(fromNodeWidget) {
              var draggingConnector = document.createElement('yb-connector');
              draggingConnector.classList.add('not-clickable');
              draggingConnector.set('fromPos', fromNodeWidget.centerPosition());
              Polymer.dom(self.root).appendChild(draggingConnector);
              self.draggingConnectors.push(draggingConnector);
            });
            
            function handleOtherNodeMouseover(event) {
              var otherNodeWidget = event.currentTarget;
              if (!self.draggingConnectorNodes.via) {
                if (!self.draggingConnectorNodes.from.has(otherNodeWidget)) {
                  self.draggingConnectorNodes.via = otherNodeWidget;
                  self.draggingConnectors.forEach(function(draggingConnector) {
                    draggingConnector.set('viaPos', otherNodeWidget.centerPosition());
                  });
                }
              } else if (!self.draggingConnectorNodes.to) {
                if (otherNodeWidget !== self.draggingConnectorNodes.via) {
                  self.draggingConnectorNodes.to = otherNodeWidget;
                  self.draggingConnectors.forEach(function(draggingConnector) {
                    draggingConnector.set('toPos', otherNodeWidget.centerPosition());
                  });
                }
              }
            }
            
            self.nodeWidgets.forEach(function(otherNodeWidget) {
              if (!self.draggingConnectorNodes.from.has(otherNodeWidget)) {
                otherNodeWidget.addEventListener('mouseover', handleOtherNodeMouseover);
              }
            });
            
            function handleMousemove(event) {
            
              var cursorPos = {
                x: event.pageX - surfaceRect.left,
                y: event.pageY - surfaceRect.top,
              }
              
              if (!self.draggingConnectorNodes.via) {
                self.draggingConnectors.forEach(function(draggingConnector) {
                  draggingConnector.set('viaPos', cursorPos);
                });
              } else if(!self.draggingConnectorNodes.to) {
                self.draggingConnectors.forEach(function(draggingConnector) {
                  draggingConnector.set('toPos', cursorPos);
                });
              }
            }
            function handleMouseup(event) {
              window.removeEventListener('mousemove', handleMousemove);
              window.removeEventListener('mouseup',   handleMouseup);
              
              self.nodeWidgets.forEach(function(otherNodeWidget) {
                if (!self.draggingConnectorNodes.from.has(otherNodeWidget)) {
                  otherNodeWidget.removeEventListener('mouseover', handleOtherNodeMouseover);
                }
              });
              
              if (self.draggingConnectorNodes.via &&
                  self.draggingConnectorNodes.to) {
                
                self.draggingConnectorNodes.from.forEach(function(fromNodeWidget) {
                  self.createConnector(fromNodeWidget,
                                       self.draggingConnectorNodes.via,
                                       self.draggingConnectorNodes.to);
                  self.client.setLink({
                    from: self.node_id.fromHex(fromNodeWidget.nodeId),
                    via:  self.node_id.fromHex(self.draggingConnectorNodes.via.nodeId),
                    to:   self.node_id.fromHex(self.draggingConnectorNodes.to.nodeId)
                  });
                });
              }
              
              self.draggingConnectors.forEach(function(draggingConnector) {
                Polymer.dom(self.root).removeChild(draggingConnector);
              });
              self.draggingConnectors = [];
            }
            
            window.addEventListener('mousemove', handleMousemove);
            window.addEventListener('mouseup',   handleMouseup);
          });
        },
        _setupNodeWidgetMenu: function(nodeWidget) {
          var self = this;
          nodeWidget.addEventListener('contextMenu', function(event) {
            if (!self.draggingConnectors.length) {
            
              self.openSelectionMenu({
                x: nodeWidget.position.x + event.detail.offsetX,
                y: nodeWidget.position.y + event.detail.offsetY,
              });
            }
          });
        },
        createConnector: function(fromWidget, viaWidget, toWidget) {
        
          var self = this;
        
          var connector = document.createElement('yb-connector');
          Polymer.dom(self.root).appendChild(connector);
          
          connector.fromWidget = fromWidget;
          connector.viaWidget  = viaWidget;
          connector.toWidget   = toWidget;
          
          fromWidget.connectorsFrom.add(connector);
          viaWidget.connectorsVia.add(connector);
          toWidget.connectorsTo.add(connector);
          
          self.connectors.add(connector);
          
          if (!self.connectorsFrom.has(fromWidget)) {
            self.connectorsFrom.set(fromWidget, [connector]);
          } else {
            self.connectorsFrom.get(fromWidget).push(connector);
          }
          
          if (!self.connectorsVia.has(viaWidget)) {
            self.connectorsVia.set(viaWidget, [connector]);
          } else {
            self.connectorsVia.get(viaWidget).push(connector);
          }
          
          if (!self.connectorsTo.has(toWidget)) {
            self.connectorsTo.set(toWidget, [connector]);
          } else {
            self.connectorsTo.get(toWidget).push(connector);
          }
          
          connector.set('fromPos', fromWidget.centerPosition());
          connector.set('viaPos',  viaWidget.centerPosition());
          connector.set('toPos',   toWidget.centerPosition());
          
          connector.addEventListener('mouseover', function(event) {
            Polymer.dom(self.root).removeChild(connector);
            Polymer.dom(self.root).appendChild(connector);
          });
          
          connector.addEventListener('selected', function(event) {
            if (!self.selectedConnectors.has(connector)) {
              if (!event.detail.ctrlKey) {
                self.deselect();
              }
              self.selectedConnectors.add(connector);
              connector.set('selected', true);
            }
          });
          
          connector.addEventListener('contextMenu', function(event) {
            self.openSelectionMenu({
              x: event.detail.offsetX,
              y: event.detail.offsetY,
            });
          });
          
          return connector;
        },
        updateConnectorsForNodeWidget: function(nodeWidget) {
          if (this.connectorsFrom.has(nodeWidget)) {
            var connectorsFrom = this.connectorsFrom.get(nodeWidget);
            connectorsFrom.forEach(function(connector) {
              connector.set('fromPos', nodeWidget.centerPosition());
            });
          }
          if (this.connectorsVia.has(nodeWidget)) {
            var connectorsVia = this.connectorsVia.get(nodeWidget);
            connectorsVia.forEach(function(connector) {
              connector.set('viaPos', nodeWidget.centerPosition());
            });
          }
          if (this.connectorsTo.has(nodeWidget)) {
            var connectorsTo = this.connectorsTo.get(nodeWidget);
            connectorsTo.forEach(function(connector) {
              connector.set('toPos', nodeWidget.centerPosition());
            })
          }
        },
        createSetWidget: function(position) {
        
          var setWidget = document.createElement('yb-set');
          
          setWidget.via = '52f9cf0e223d559931856acc98400f21';
          setWidget.to  = '7e1b27583610201f8b48941d3637b13f';
          setWidget.style.position = 'absolute';
          setWidget.style.left = position.x + 'px';
          setWidget.style.top  = position.y + 'px';
          setWidget.position = position;
          setWidget.style['min-width']  = "150px";
          setWidget.style['max-width']  = "400px";
          setWidget.style['min-height'] = "50px";
          
          this._setupSetWidgetSelection(setWidget);
          this._setupSetWidgetMenu(setWidget);
          this._setupSetWidgetDragging(setWidget);
          
          Polymer.dom(this.root).appendChild(setWidget);
          this.setWidgets.add(setWidget);
          
          return setWidget;
        },
        _setupSetWidgetSelection: function(setWidget) {
          var self = this;
          setWidget.addEventListener('selected', function(event) {
            if (!self.selectedSetWidgets.has(setWidget)) {
              if (!event.detail.ctrlKey) {
                self.deselect();
              }
              self.selectedSetWidgets.add(setWidget);
              setWidget.set('selected', true);
            }
          });
        },
        _setupSetWidgetDragging: function(setWidget) {
          var self = this;
          setWidget.addEventListener('dragStart', function(event) {
            self.startDraggingSelected(event);
          });
        },
        _setupSetWidgetMenu: function(setWidget) {
          var self = this;
          setWidget.addEventListener('contextMenu', function(event) {
            if (!self.draggingConnectors.length) {
            
              self.openSelectionMenu({
                x: setWidget.position.x + event.detail.offsetX,
                y: setWidget.position.y + event.detail.offsetY,
              });
            }
          });
        },
        openSelectionMenu: function(position) {
          if (this.$.backgroundDropdown.opened) {
            this.$.backgroundDropdown.close();
          }
          
          this.$.selectionDropdown.set('horizontalOffset', position.x);
          this.$.selectionDropdown.set('verticalOffset',   position.y);
          if (!this.$.selectionDropdown.opened) {
            this.$.selectionDropdown.open();
          }
        },
        menuItem_CreateNode: function() {
          this.$.backgroundDropdown.close();
          this.createNodeWidget(this.lastMenuPosition);
        },
        menuItem_CreateSet: function() {
          this.$.backgroundDropdown.close();
          this.createSetWidget(this.lastMenuPosition);
        },
        menuItem_DeleteSelected: function() {
          var self = this;
          self.$.selectionDropdown.close();
          var linksToDelete = self.removeSelectedWidgets();
          linksToDelete.forEach(function(linkKey) {
            self.client.unsetLink(self.node_id.linkFromKey(linkKey));
          });
        },
        menuItem_HideSelected: function() {
          this.$.selectionDropdown.close();
          this.removeSelectedWidgets();
        },
        menuItem_CopySelected: function() {
          this.$.selectionDropdown.close();
          var offset = 10;
          this.copySelected(offset);
        },
        menuItem_RevealLinks: function() {
          this.$.selectionDropdown.close();
          this.revealLinksInSelected();
        },
        menuItem_HideLinks: function() {
          this.$.selectionDropdown.close();
          this.removeSelectedConnectors();
          this.removeConnectorsBetweenSelectedNodeWidgets();
        },
      });
    })();
  </script>

</dom-module>