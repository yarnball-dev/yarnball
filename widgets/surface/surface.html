<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/iron-dropdown/iron-dropdown.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-menu/paper-menu.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/paper-item/paper-icon-item.html">

<link rel="import" href="../node/node.html">
<link rel="import" href="../connector/connector.html">
<link rel="import" href="../set/set.html">
<link rel="import" href="../all-nodes/all-nodes.html">

<link rel="import" href="surface-styles.html">

<dom-module id="yb-surface">

  <style include="surface-styles"></style>

  <template>
  
    <div id="viewRoot">
    
      <div id="background" on-mousedown="backgroundMousedown"></div>
    
      <div id="boxSelection" class="hidden"></div>
    
    </div>
    
    <paper-button id="fullscreenButton" on-tap="toggleFullscreen">
      <iron-icon icon="icons:fullscreen" item-icon></iron-icon>
    </paper-button>
    
    <div id="searchPanel" class="closed">
      <div class="panel-handle" on-tap="toggleSearchPanel">
        <iron-icon icon="icons:search" item-icon></iron-icon>
      </div>
      <yb-all-nodes id="allNodesList"></yb-all-nodes>
    </div>
    
    <iron-dropdown id="backgroundDropdown" horizontal-align="left" vertical-align="top">
      <div class="dropdown-content">
        <paper-menu>
          <paper-icon-item on-tap="menuItem_CreateNode">
            <iron-icon icon="icons:add" item-icon></iron-icon>
            Add Node
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_CreateSet">
            <iron-icon icon="icons:add" item-icon></iron-icon>
            Add Set
          </paper-icon-item>
        </paper-menu>
      </div>
    </iron-dropdown>
    
    <iron-dropdown id="selectionDropdown" horizontal-align="left" vertical-align="top">
      <div class="dropdown-content">
        <paper-menu>
          <paper-icon-item on-tap="menuItem_CopySelected">
            <iron-icon icon="icons:content-copy" item-icon></iron-icon>
            Copy
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_RevealLinks">
            <iron-icon icon="icons:visibility" item-icon></iron-icon>
            Reveal Links
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_HideLinks">
            <iron-icon icon="icons:visibility-off" item-icon></iron-icon>
            Hide Links
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_HideSelected">
            <iron-icon icon="icons:visibility-off" item-icon></iron-icon>
            Hide
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_DeleteSelected">
            <iron-icon icon="icons:delete" item-icon></iron-icon>
            Delete
          </paper-icon-item>
        </paper-menu>
      </div>
    </iron-dropdown>
      
  </template>
  
  <script>
    (function() {
      'use strict';
      
      Polymer({
        is: 'yb-surface',
        behaviors: [
          Polymer.IronA11yKeysBehavior,
        ],
        created: function() {
          var self = this;
          
          self.viewTranslate = {x: 0, y: 0};
          self.viewScale     = 1.0;
          self.viewOrigin    = {x: 0, y: 0};
          self.viewMargin    = 10000;
          self.isFullscreen  = false;
          
          self.widgets       = new Set();
          self.widgetsOfType = new Map();
          self.widgetsTopLevel = new Set();
          
          self.selectedWidgets = new Set();
          
          self.nodesToWidgets = new Map();
          
          self.connectorsFrom = new Map();
          self.connectorsVia  = new Map();
          self.connectorsTo   = new Map();
          self.activeConnectors = new Set();
          self.linksToConnectors = new Map();
          self.nodeWidgetsToConnectors = new Map();
          
          self.dragdropAreas = new Set();
          
          self.currentOperation = null;
          
          require(['core/client', 'core/node_id'], function(client, node_id) {
            self.client  = client;
            self.node_id = node_id;
          });
        },
        ready: function() {
        
          var self = this;
          
          self.viewRoot = self.$.viewRoot;
          self.background = self.$.background;
          self.searchPanel = self.$.searchPanel;
          self.boxSelection = self.$.boxSelection;
          
          self.setView(self.viewTranslate, self.viewScale, self.viewOrigin);
        
          require(['core/client', 'core/node_id'], function(client, node_id) {
            self.client  = client;
            self.node_id = node_id;
            
            self.onLinks = self.onLinks.bind(self);
            client.onLinks(self.onLinks);
        
            self.attachWidget(self.createNodeWidget(node_id.fromHex('52f9cf0e223d559931856acc98400f21')), {x: 100, y: 40});
            self.attachWidget(self.createNodeWidget(node_id.fromHex('1264ed87a8274e5188f9020954811805')), {x: 100, y: 100});
            self.attachWidget(self.createNodeWidget(node_id.fromHex('5c4d67cf88fd9c5dbc841dee378b6b4b')), {x: 100, y: 160});
            self.attachWidget(self.createNodeWidget(node_id.fromHex('7e1b27583610201f8b48941d3637b13f')), {x: 185, y: 160});
          });
          
          // Install operations
          require(
            [
              '/widgets/surface/pan-operation.js',
              '/widgets/surface/zoom-operation.js',
              '/widgets/surface/selection-operation.js',
              '/widgets/surface/box-selection-operation.js',
              '/widgets/surface/drag-operation.js',
              '/widgets/surface/new-connector-drag-operation.js',
            ],
            function() {
              var operations = Array.from(arguments);
              operations.forEach(function(operation) {
                operation.install(self);
              });
            }
          );
          
          // Fullscreen event handling
          self.handleFullscreenEvent       = self.handleFullscreenEvent.bind(self);
          self.handleWebkitFullscreenEvent = self.handleWebkitFullscreenEvent.bind(self);
          self.handleMozFullscreenEvent    = self.handleMozFullscreenEvent.bind(self);
          self.handleMSFullscreenEvent     = self.handleMSFullscreenEvent.bind(self);
          if (self.requestFullscreen) {
            document.addEventListener('fullscreenchange',       self.handleFullscreenEvent);
          } else if (self.webkitRequestFullscreen) {
            document.addEventListener('webkitfullscreenchange', self.handleWebkitFullscreenEvent);
          } else if (self.mozRequestFullScreen) {
            document.addEventListener('mozfullscreenchange',    self.handleMozFullscreenEvent);
          } else if (self.msRequestFullscreen) {
            document.addEventListener('MSFullscreenChange',     self.handleMSFullscreenEvent);
          }
        },
        detached: function() {
          this.client.removeLinksListener(this.onLinks);
          
          if (self.requestFullscreen) {
            document.removeEventListener('fullscreenchange',       self.handleFullscreenEvent);
          } else if (self.webkitRequestFullscreen) {
            document.removeEventListener('webkitfullscreenchange', self.handleWebkitFullscreenEvent);
          } else if (self.mozRequestFullScreen) {
            document.removeEventListener('mozfullscreenchange',    self.handleMozFullscreenEvent);
          } else if (self.msRequestFullscreen) {
            document.removeEventListener('MSFullscreenChange',     self.handleMSFullscreenEvent);
          }
        },
        handleFullscreenEvent: function(event) {
          this.isFullscreen = document.fullscreenEnabled && document.fullscreenElement === this;
          this.classList.toggle('fullscreen', this.isFullscreen);
        },
        handleWebkitFullscreenEvent: function(event) {
          this.isFullscreen = document.webkitFullscreenEnabled && document.webkitFullscreenElement === this;
          this.classList.toggle('fullscreen', this.isFullscreen);
        },
        handleMozFullscreenEvent: function(event) {
          this.isFullscreen = document.mozFullScreenEnabled && document.mozFullScreenElement === this;
          this.classList.toggle('fullscreen', this.isFullscreen);
        },
        handleMSFullscreenEvent: function(event) {
          this.isFullscreen = document.msFullscreenEnabled && document.msFullscreenElement === this;
          this.classList.toggle('fullscreen', this.isFullscreen);
        },
        enterFullscreen: function(event) {
          if (!this.isFullscreen) {
            if (this.requestFullscreen) {
              this.requestFullscreen();
            } else if (this.msRequestFullscreen) {
              this.msRequestFullscreen();
            } else if (this.mozRequestFullScreen) {
              this.mozRequestFullScreen();
            } else if (this.webkitRequestFullscreen) {
              this.webkitRequestFullscreen();
            }
          }
        },
        exitFullscreen: function() {
          if (this.isFullscreen) {
            if (document.exitFullscreen) {
              document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
              document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
              document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
              document.msExitFullscreen();
            }
          }
        },
        toggleFullscreen: function(event) {
          if (!this.isFullscreen) {
            this.enterFullscreen(event);
          } else {
            this.exitFullscreen();
          }
        },
        toggleSearchPanel: function() {
          if (document.activeElement !== this.$.allNodesList.searchTextbox) {
            this.searchPanel.classList.remove('closed');
            this.$.allNodesList.searchTextbox.focus();
            this.$.allNodesList.searchTextbox.select();
          } else {
            this.searchPanel.classList.add('closed');
            this.focus();
          }
        },
        hasOperation: function() {
          return this.currentOperation !== null;
        },
        beginOperation: function(operation /* ... */) {
          if (this.currentOperation != null) {
            return null;
          }
          this.currentOperation = new operation();
          this.currentOperation.surface = this;
          var args = Array.prototype.slice.call(arguments, 1);
          this.currentOperation.begin.apply(this.currentOperation, args);
          return this.currentOperation;
        },
        finishOperation: function(operation) {
          operation.finish();
          if (this.currentOperation === operation) {
            this.currentOperation = null;
          }
        },
        listeners: {
          contextmenu: 'oncontextmenu',
          widgetAttached: 'widgetAttached',
          widgetDetached: 'widgetDetached',
          dragdropAreaAttached: 'dragdropAreaAttached',
          dragdropAreaDetached: 'dragdropAreaDetached',
        },
        translateMouseEvent: function(event) {
          var targetBoundingClientRect = event.target.getBoundingClientRect();
          var viewRootBoundingClientRect = this.viewRoot.getBoundingClientRect();
          return {
            positionPage: {
              x: event.pageX,
              y: event.pageY,
            },
            positionClient: {
              x: event.clientX,
              y: event.clientY,
            },
            positionView: {
              x: (event.clientX - viewRootBoundingClientRect.left) / this.viewScale,
              y: (event.clientY - viewRootBoundingClientRect.top)  / this.viewScale,
            },
            positionTarget: {
              x: (event.clientX - targetBoundingClientRect.left) / this.viewScale,
              y: (event.clientY - targetBoundingClientRect.top)  / this.viewScale,
            },
          }
        },
        captureMouse: function(event, options) {
        
          var self = this;
        
          var cusorBeforeMouseCapture = document.body.style.cursor;
          
          if ('cursor' in options) {
            document.body.style.cursor = options.cursor;
          }
          
          var startMouseEventTranslated = self.translateMouseEvent(event);

          var lastMouseEventTranslated = startMouseEventTranslated;
          
          self.classList.add('mouse-captured');
          
          self.$.background.addEventListener('mousemove', mousemove);
          
          function mousemove(event) {
          
            event.stopImmediatePropagation();
            
            var mouseEventTranslated = self.translateMouseEvent(event);
            
            var dragDeltaView = {
              x: mouseEventTranslated.positionView.x - startMouseEventTranslated.positionView.x,
              y: mouseEventTranslated.positionView.y - startMouseEventTranslated.positionView.y,
            }
            
            var dragDeltaPage = {
              x: mouseEventTranslated.positionPage.x - startMouseEventTranslated.positionPage.x,
              y: mouseEventTranslated.positionPage.y - startMouseEventTranslated.positionPage.y,
            }
            
            var currentDeltaPage = {
              x: mouseEventTranslated.positionPage.x - lastMouseEventTranslated.positionPage.x,
              y: mouseEventTranslated.positionPage.y - lastMouseEventTranslated.positionPage.y,
            }
            
            var currentDeltaView = {
              x: mouseEventTranslated.positionView.x - lastMouseEventTranslated.positionView.x,
              y: mouseEventTranslated.positionView.y - lastMouseEventTranslated.positionView.y,
            }
            
            if ('mousemove' in options) {
              options.mousemove({
                event: event,
                currentPosPage: mouseEventTranslated.positionPage,
                currentPosView: mouseEventTranslated.positionView,
                dragDeltaPage: dragDeltaPage,
                dragDeltaView: dragDeltaView,
                currentDeltaPage: currentDeltaPage,
                currentDeltaView: currentDeltaView,
              });
            }
            
            lastMouseEventTranslated = mouseEventTranslated;
          }
          
          function mouseup(event) {
          
            self.$.background.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup',   mouseup);
            
            document.body.style.cursor = cusorBeforeMouseCapture;
          
            self.classList.remove('mouse-captured');
            
            if ('mouseup' in options) {
              options.mouseup(event);
            }
          }
          
          window.addEventListener('mouseup',   mouseup);
        },
        setView: function(translate, scale, origin) {
          this.viewTranslate = translate;
          this.viewScale     = scale;
          this.viewOrigin    = origin;
          this.viewRoot.style.transform = 'translate(' + translate.x + 'px, ' + translate.y + 'px) scale(' + scale + ')';
          this.viewRoot.style['transform-origin'] = origin.x + 'px ' + origin.y + 'px';
        },
        moveView: function(offset) {
          this.setView({
              x: this.viewTranslate.x + offset.x,
              y: this.viewTranslate.y + offset.y,
            },
            this.viewScale,
            this.viewOrigin
          );
        },
        zoom: function(zoomOffset) {
          var surfaceRect = this.getBoundingClientRect();
          var viewRootRect = this.viewRoot.getBoundingClientRect();
          var surfaceCenter = {
            x: surfaceRect.left + (surfaceRect.width  / 2),
            y: surfaceRect.top  + (surfaceRect.height / 2),
          }
          this.zoomOnPosition(
            {
              x: (surfaceCenter.x - viewRootRect.left) / this.viewScale,
              y: (surfaceCenter.y - viewRootRect.top)  / this.viewScale,
            },
            zoomOffset,
            true
          );
        },
        zoomOnPosition: function(position, zoomOffset) {
          this.setView(
            {
              x: this.viewTranslate.x + ((position.x - this.viewOrigin.x) * (this.viewScale - 1.0)),
              y: this.viewTranslate.y + ((position.y - this.viewOrigin.y) * (this.viewScale - 1.0)),
            },
            this.viewScale * (1.0 + zoomOffset),
            {
              x: position.x,
              y: position.y,
            }
          );
        },
        oncontextmenu: function(event) {
          event.preventDefault();
          return false;
        },
        backgroundMousedown: function(event) {
        
          this.closeBackgroundMenu();
          this.closeSelectionMenu();
          
          this.focus();
          
          var mouseEvent = this.translateMouseEvent(event);
          
          if (event.button === 0) {
            
            if (event.shiftKey) {
              var nodeWidget = this.createNodeWidget();
              this.attachWidget(nodeWidget, {
                x: mouseEvent.positionView.x - 28,
                y: mouseEvent.positionView.y - 28,
              });
            } else {
              if (!event.ctrlKey) {
                this.deselect();
              }
            }
            
          } else if (event.button === 2) {
          
            if (!event.ctrlKey) {
              this.deselect();
            }
          
            this.lastMenuPosition = mouseEvent.positionView;
          
            var surfaceRect = this.getBoundingClientRect();
          
            this.openBackgroundMenu({
              x: event.pageX - surfaceRect.left,
              y: event.pageY - surfaceRect.top,
            });
            return false;
          }
        },
        keyBindings: {
          'backspace':  'handleKey_Backspace',
          'del delete': 'handleKey_Del',
          'ctrl+a':     'handleKey_CtrlA',
          'ctrl+d':     'handleKey_CtrlD',
          'pageup':     'handleKey_PageUp',
          'pagedown':   'handleKey_PageDown',
          'ctrl+enter': 'handleKey_CtrlEnter',
          'ctrl+f':     'handleKey_CtrlF',
        },
        handleKey_Backspace: function(event) {
          if (document.activeElement === this) {
            event.preventDefault();
            this.hideSelectedWidgets();
            return false;
          }
        },
        handleKey_Del: function(event) {
          event.preventDefault();
          this.deleteSelected();
          return false;
        },
        handleKey_CtrlA: function(event) {
          event.preventDefault();
          this.selectAll();
          return false;
        },
        handleKey_CtrlD: function(event) {
          event.preventDefault();
          this.deselect();
          return false;
        },
        handleKey_PageUp: function(event) {
          event.preventDefault();
          this.zoom(0.2);
          return false;
        },
        handleKey_PageDown: function(event) {
          event.preventDefault();
          this.zoom(-0.2);
          return false;
        },
        handleKey_CtrlEnter: function(event) {
          event.preventDefault();
          this.toggleFullscreen();
          return false;
        },
        handleKey_CtrlF: function(event) {
          event.preventDefault();
          this.toggleSearchPanel();
          return false;
        },
        getElementViewRect: function(element) {
          var elementClientRect = element.getBoundingClientRect();
          var viewRootClientRect = this.viewRoot.getBoundingClientRect();
          return {
            left:   (elementClientRect.left   - viewRootClientRect.left) / this.viewScale,
            top:    (elementClientRect.top    - viewRootClientRect.top)  / this.viewScale,
            right:  (elementClientRect.right  - viewRootClientRect.left) / this.viewScale,
            bottom: (elementClientRect.bottom - viewRootClientRect.top)  / this.viewScale,
            width:  elementClientRect.width / this.viewScale,
            height: elementClientRect.height / this.viewScale,
          }
        },
        getWidgetsTopLevel: function() {
          return new Set(this.widgetsTopLevel);
        },
        getWidgetsTopLevelOfType: function(type) {
          var self = this;
          return new Set(Array.from(self.getWidgetsOfType(type)).filter(function(widget) {
            return self.widgetsTopLevel.has(widget);
          }));
        },
        getWidgetsOfType: function(type) {
          return new Set(Array.from(this.widgets).filter(function(widget) {
            return widget.tagName === type.toUpperCase();
          }));
        },
        getWidgetPosition: function(widget) {
          var viewRect = this.getElementViewRect(widget);
          return {
            x: viewRect.left,
            y: viewRect.top,
          }
        },
        getWidgetCenter: function(widget) {
          var nodeRect = this.getElementViewRect(widget);
          return {
            x: nodeRect.left + (nodeRect.width  / 2),
            y: nodeRect.top  + (nodeRect.height / 2),
          }
        },
        getWidgetsInRect: function(rect) {
          var self = this;
          return Array.from(self.widgets).filter(function(widget) {
            if (widget.widgetHandle && !widget.widgetHandle.classList.contains('hidden')) {
              var widgetRect = self.getElementViewRect(widget.widgetHandle);
              return !(widgetRect.left > rect.right  || widgetRect.right  < rect.left ||
                      widgetRect.top  > rect.bottom || widgetRect.bottom < rect.top);
            }
          });
        },
        getWidgetsForNode: function(id) {
          var idMapKey = this.node_id.toMapKey(id);
          if (this.nodesToWidgets.has(idMapKey)) {
            return this.nodesToWidgets.get(idMapKey);
          } else {
            return new Set();
          }
        },
        getTopLevelWidgetsForNode: function(id) {
          var self = this;
          return new Set(Array.from(self.getWidgetsForNode(id)).filter(function(widget) {
            return self.isTopLevelWidget(widget);
          }));
        },
        getWidgetDragdropAreaParent: function(widget) {
          if (widget.parentNode) {
            if (widget.parentNode.tagName === 'yb-dragdrop-area'.toUpperCase()) {
              return widget.parentNode;
            } else {
              return this.getWidgetDragdropAreaParent(widget.parentNode);
            }
          } else {
            return null;
          }
        },
        getTopLevelNodeWidgetTriplesForLink: function(link, nodeWidgets) {
          var self = this;
          
          var nodeWidgetsFrom = self.getTopLevelWidgetsForNode(link.from);
          var nodeWidgetsVia  = self.getTopLevelWidgetsForNode(link.via);
          var nodeWidgetsTo   = self.getTopLevelWidgetsForNode(link.to);
          
          if (nodeWidgets) {
            nodeWidgetsFrom = Array.from(nodeWidgetsFrom).filter(function(nodeWidget) {
              return nodeWidgets.has(nodeWidget);
            });
            nodeWidgetsVia = Array.from(nodeWidgetsVia).filter(function(nodeWidget) {
              return nodeWidgets.has(nodeWidget);
            });
            nodeWidgetsTo = Array.from(nodeWidgetsTo).filter(function(nodeWidget) {
              return nodeWidgets.has(nodeWidget);
            });
          }
          
          var nodeWidgetTriples = [];
        
          nodeWidgetsFrom.forEach(function(fromWidget) {
            nodeWidgetsVia.forEach(function(viaWidget) {
              nodeWidgetsTo.forEach(function(toWidget) {
                
                nodeWidgetTriples.push({
                  from: fromWidget,
                  via:  viaWidget,
                  to:   toWidget
                });
              });
            });
          });
          
          return nodeWidgetTriples;
        },
        getNodeWidgetTripleDistance: function(nodeWidgetTriple) {
          function distance(a, b) {
            var dx = a.x - b.x;
            var dy = a.y - b.y;
            return Math.sqrt(dx*dx + dy*dy);
          }
          
          var fromPos = this.getWidgetCenter(nodeWidgetTriple.from);
          var viaPos  = this.getWidgetCenter(nodeWidgetTriple.via);
          var toPos   = this.getWidgetCenter(nodeWidgetTriple.to);
          
          return distance(fromPos, viaPos) + distance(viaPos, toPos);
        },
        makeConnectorsForLink: function(link, newConnectorOptions, nodeWidgets) {
          var self = this;
          
          var returnValues = {
            connectors: [],
            newConnectors: [],
            existingConnectors: [],
          }
        
          var nodeWidgetTriples = self.getTopLevelNodeWidgetTriplesForLink(link, nodeWidgets);
          if (!nodeWidgetTriples.length) {
            return returnValues;
          }
          
          nodeWidgetTriples.sort(function(a, b) {
            return self.getNodeWidgetTripleDistance(a) - self.getNodeWidgetTripleDistance(b);
          });
          
          var nodeWidgetsUsed = new Set();
          
          nodeWidgetTriples.forEach(function(nodeWidgetTriple) {
          
            var connector = self.getConnectorForNodeWidgetTriple(nodeWidgetTriple);
            
            if (connector) {
              returnValues.existingConnectors.push(connector);
            }
            
            if (!connector &&
                !nodeWidgetsUsed.has(nodeWidgetTriple.from) &&
                !nodeWidgetsUsed.has(nodeWidgetTriple.via)  &&
                !nodeWidgetsUsed.has(nodeWidgetTriple.to)) {
              
              connector = self.createConnector(nodeWidgetTriple, newConnectorOptions);
              returnValues.newConnectors.push(connector);
            }
            
            if (connector) {
              returnValues.connectors.push(connector);
            }
            
            nodeWidgetsUsed.add(nodeWidgetTriple.from);
            nodeWidgetsUsed.add(nodeWidgetTriple.via);
            nodeWidgetsUsed.add(nodeWidgetTriple.to);
          });
          
          return returnValues;
        },
        getConnectorsForLink: function(link) {
          var linkKey = this.node_id.linkToKey(link);
          if (this.linksToConnectors.has(linkKey)) {
            return new Set(Array.from(this.linksToConnectors.get(linkKey)));
          } else {
            return new Set();
          }
        },
        getConnectorsBetweenNodeWidgets: function(nodeWidgets) {
          return Array.from(this.getWidgetsOfType('yb-connector')).filter(function(connector) {
            return nodeWidgets.has(connector.fromWidget) &&
                   nodeWidgets.has(connector.viaWidget) &&
                   nodeWidgets.has(connector.toWidget);
          });
        },
        getConnectorsTouchingNodeWidgets: function(nodeWidgets) {
          var connectors = new Set();
          nodeWidgets.forEach(function(nodeWidget) {
            nodeWidget.connectors().forEach(function(connector) {
              connectors.add(connector);
            });
          });
          return connectors;
        },
        getConnectorForNodeWidgetTriple: function(nodeWidgetsTriple) {
          var nodeWidgetsLinkKey = this.node_id.linkToKey({
            from: nodeWidgetsTriple.from.widgetId,
            via:  nodeWidgetsTriple.via.widgetId,
            to:   nodeWidgetsTriple.to.widgetId,
          });
          return this.nodeWidgetsToConnectors.get(nodeWidgetsLinkKey);
        },
        getDragdropAreas: function() {
          return new Set(this.dragdropAreas);
        },
        onLinks: function(linksAdded, linksRemoved) {
          var self = this;
          
          var addedConnectorAnimations = self.highlightLinks(linksAdded, {color: '#2FB51E'});
          addedConnectorAnimations.forEach(function(animation, connector) {
            if (!self.activeConnectors.has(connector)) {
              animation.then(
                function() {
                  self.removeWidget(connector);
                },
                function() { }
              );
            }
          });
          
          var removeConnectorAnimations = self.highlightLinks(linksRemoved, {color: '#E05749', fadeOut: true, reverse: true});
          removeConnectorAnimations.forEach(function(animation, connector) {
            animation.then(
              function() {
                self.removeWidget(connector);
              },
              function() { }
            );
          });
        },
        highlightLinks: function(links, options) {
          var self = this;
          var connectorAnimations = new Map();
          links.forEach(function(link) {
            var result = self.makeConnectorsForLink(link, {active: false});
            result.connectors.forEach(function(connector) {
              var animation = self.highlightConnector(connector, options);
              connectorAnimations.set(connector, animation);
            });
          });
          return connectorAnimations;
        },
        highlightConnector: function(connector, options) {
          var self = this;
          var animationDuration = 300;
          if (connector.highlightAnimation) {
            connector.highlightAnimation.cancel();
            connector.highlightAnimation = null;
          }
          var color   = ('color'   in options) ? options.color   : '#fff';
          var fadeOut = ('fadeOut' in options) ? options.fadeOut : !self.activeConnectors.has(connector);
          var reverse = ('reverse' in options) ? options.reverse : false;
          var delay   = ('delay'   in options) ? options.delay : 0;
          var pathLength = connector.path.getTotalLength();
          connector.highlightAnimation = connector.path.animate(
            [
              {stroke: color, opacity: 1.0,                 'stroke-dasharray':  pathLength, 'stroke-dashoffset': reverse ? 0               : pathLength},
              {stroke: color, opacity: fadeOut ? 0.5 : 1.0, 'stroke-dasharray':  pathLength, 'stroke-dashoffset': reverse ? 0               : 0         },
              {stroke: color, opacity: fadeOut ? 0.0 : 1.0, 'stroke-dasharray':  pathLength, 'stroke-dashoffset': reverse ? -pathLength     : 0         },
            ],
            {
              duration: animationDuration,
              fill: fadeOut ? 'both' : 'backwards',
              delay: delay,
            }
          );
          return connector.highlightAnimation.finished;
        },
        createNodeWidget: function(id) {
        
          var nodeWidget = document.createElement('yb-node');
          if (!id) {
            id = this.node_id.make();
          }
          nodeWidget.set('nodeId', this.node_id.toHex(id));
          
          return nodeWidget;
        },
        attachWidget: function(widget, position) {
          var self = this;
          
          if (position) {
            widget.style.position = 'absolute';
            widget.style.left = position.x + 'px';
            widget.style.top  = position.y + 'px';
          }
          
          Polymer.dom(self.viewRoot).appendChild(widget);
        },
        detachWidget: function(widget) {
          widget.classList.remove('yb-surface');
          this.widgetDetached({detail: widget});
          return Polymer.dom(this.viewRoot).removeChild(widget);
        },
        removeWidget: function(widget) {
          this.widgetDetached({detail: widget});
          Polymer.dom(this.viewRoot).removeChild(widget);
        },
        widgetAttached: function(event) {
          var self = this;
          
          var widget = event.detail;
          
          if (!self.widgets.has(widget)) {
          
            self.widgets.add(widget);
            
            var widgetType = widget.tagName.toLowerCase();
            
            if (!self.widgetsOfType.has()) {
              self.widgetsOfType.set(widgetType, new Set([widget]))
            } else {
              self.widgetsOfType.get(widgetType).add(widget);
            }
            
            if (widgetType === 'yb-node') {
            
              var idMapKey = self.node_id.toMapKey(self.node_id.fromHex(widget.nodeId));
              
              if (!self.nodesToWidgets.has(idMapKey)) {
                self.nodesToWidgets.set(idMapKey, new Set([widget]));
              } else {
                self.nodesToWidgets.get(idMapKey).add(widget);
              }
            
              self._setupNodeWidgetHighlighting(widget);
              self._setupNodeWidgetMenu(widget);
              
            } else if (widgetType === 'yb-set') {
            
              self._setupSetWidgetMenu(widget);
            }
          }
          
          if (widget.parentNode === self.viewRoot) {
            if (!self.widgetsTopLevel.has(widget)) {
              self.widgetsTopLevel.add(widget);
              widget.addEventListener('dimensionsChanged', function(event) {
                self.updateConnectorsForNodeWidget(widget);
              });
            }
          } else {
            self.widgetsTopLevel.delete(widget);
          }
        },
        widgetDetached: function(event) {
          var self = this;
        
          var widget = event.detail;
          
          var widgetType = widget.tagName.toLowerCase();
          
          if (widgetType === 'yb-node') {
          
            if (self.widgetsTopLevel.has(widget)) {
            
              Array.from(widget.connectors()).forEach(function(connector) {
                self.removeWidget(connector);
              });
            }
            
          } else if (widgetType === 'yb-connector') {
          
            var linkKey = self.node_id.linkToKey({
              from: self.node_id.fromHex(widget.fromWidget.nodeId),
              via:  self.node_id.fromHex(widget.viaWidget.nodeId),
              to:   self.node_id.fromHex(widget.toWidget.nodeId),
            });
            if (self.linksToConnectors.has(linkKey)) {
              var connectors = self.linksToConnectors.get(linkKey);
              connectors.delete(widget);
              if (connectors.size === 0) {
                self.linksToConnectors.delete(linkKey);
              }
            }
            
            var nodeWidgetsKey = self.node_id.linkToKey({
              from: widget.fromWidget.widgetId,
              via:  widget.viaWidget.widgetId,
              to:   widget.toWidget.widgetId,
            });
            self.nodeWidgetsToConnectors.delete(nodeWidgetsKey);
            
            widget.fromWidget.connectorsFrom.delete(widget);
            widget.viaWidget.connectorsVia.delete(widget);
            widget.toWidget.connectorsTo.delete(widget);
            
            if (widget.highlightAnimation) {
              widget.highlightAnimation.cancel();
              widget.highlightAnimation = null;
            }
          }
          
          self.widgets.delete(widget);
          self.widgetsTopLevel.delete(widget);
        },
        _setupNodeWidgetHighlighting: function(nodeWidget) {
          var self = this;
          nodeWidget.addEventListener('mouseover', function(event) {
            var nodeCopies = [];
            self.getWidgetsOfType('yb-node').forEach(function(otherNodeWidget) {
              if (otherNodeWidget !== nodeWidget && otherNodeWidget.nodeId === nodeWidget.nodeId) {
                nodeCopies.push(otherNodeWidget);
                otherNodeWidget.set('highlighted', true);
              }
            });
            function stopHighlighting() {
              nodeWidget.removeEventListener('mouseout', stopHighlighting);
              nodeWidget.removeEventListener('detached', stopHighlighting);
              nodeCopies.forEach(function(nodeWidgetCopy) {
                nodeWidgetCopy.set('highlighted', false);
              });
            }
            nodeWidget.addEventListener('mouseout', stopHighlighting);
            nodeWidget.addEventListener('detached', stopHighlighting);
          });
        },
        bringNodeWidgetToFront: function(nodeWidget) {
        },
        bringConnectorToFront: function(connector) {
          Polymer.dom(this.viewRoot).appendChild(connector);
        },
        bringSetWidgetToFront: function(setWidget) {
          Polymer.dom(this.viewRoot).appendChild(setWidget);
        },
        isWidgetSelected: function(widget) {
          return this.selectedWidgets.has(widget);
        },
        selectWidgets: function(widgets, appendSelection) {
          var self = this;
          
          widgets = new Set(widgets);
          
          if (appendSelection) {
            self.selectedWidgets.forEach(function(widget) {
              widgets.add(widget);
            });
          }
          
          // Deselect previously selected widgets
          self.selectedWidgets.forEach(function(widget) {
            if (!widgets.has(widget)) {
              widget.set('selected', false);
            }
          });
          
          // Select new widgets
          widgets.forEach(function(widget) {
            if (!self.selectedWidgets.has(widget)) {
              widget.set('selected', true);
            }
          });
          
          self.selectedWidgets = widgets;
        },
        selectAll: function() {
          this.selectWidgets(this.widgets);
        },
        deselect: function() {
          this.selectedWidgets.forEach(function(widget) {
            widget.set('selected', false);
          });
          this.selectedWidgets.clear();
        },
        isTopLevelWidget: function(widget) {
          return widget.parentNode === this.viewRoot;
        },
        setWidgetPosition: function(widget, position) {
          widget.style.left = position.x + 'px';
          widget.style.top  = position.y + 'px';
          
          if (widget.tagName === 'yb-node'.toUpperCase()) {
            this.updateConnectorsForNodeWidget(widget);
          }
        },
        getSelectedWidgets: function() {
          return new Set(this.selectedWidgets);
        },
        getSelectedWidgetsTopLevel: function() {
          var self = this;
          return new Set(Array.from(self.selectedWidgets).filter(function(widget) {
            return self.isTopLevelWidget(widget);
          }));
        },
        getSelectedWidgetsOfType: function(type) {
          return new Set(Array.from(this.selectedWidgets).filter(function(widget) {
            return widget.tagName === type.toUpperCase();
          }));
        },
        hideSelectedWidgets: function() {
          var self = this;
          self.getSelectedWidgetsTopLevel().forEach(function(widget) {
            self.removeWidget(widget);
          });
        },
        deleteSelected: function() {
          var self = this;
        
          var widgetsToRemove = new Set(self.getSelectedWidgetsTopLevel());
          
          self.getConnectorsTouchingNodeWidgets(self.getSelectedWidgetsOfType('yb-node')).forEach(function(connector) {
            widgetsToRemove.add(connector);
          });
          
          var linkKeysToRemove = new Set(Array.from(self.getSelectedWidgetsOfType('yb-connector')).map(function(connector) {
            return self.node_id.linkToKey(connector.link());
          }));
          var linksToRemove = Array.from(linkKeysToRemove).map(function(linkKey) {
            return self.node_id.linkFromKey(linkKey);
          });
          
          widgetsToRemove.forEach(function(widget) {
            self.removeWidget(widget);
          });

          self.client.removeLinks(linksToRemove);
        },
        hideConnector: function(connector) {
          var self = this;
          self.activateConnector(connector, false);
          self.highlightConnector(connector, {color: '#E05749', fadeOut: true, reverse: true}).then(
            function() {
              self.removeWidget(connector);
            },
            function() { }
          );
        },
        duplicateWidgets: function(widgets, offset) {
          var self = this;
          
          var newWidgets = [];
          
          var oldToNewNodeWidgetMap = new Map();
          
          // Duplcate nodes and sets
          widgets.forEach(function(widget) {
            var widgetType = widget.tagName.toLowerCase();
            
            var newWidget = null;
            
            if (widgetType === 'yb-node') {
              newWidget = self.createNodeWidget(self.node_id.fromHex(widget.nodeId));
              oldToNewNodeWidgetMap.set(widget, newWidget);
            } else if (widgetType === 'yb-set') {
              newWidget = self.createSetWidget(widget.getFilter());
            }
            
            if (newWidget) {
              var widgetPosition = self.getWidgetPosition(widget);
              var newPosition = {
                x: widgetPosition.x + (offset || 0),
                y: widgetPosition.y + (offset || 0),
              }
              self.attachWidget(newWidget, newPosition);
              newWidgets.push(newWidget);
            }
          });
          
          // Duplcate connectors
          widgets.forEach(function(widget) {
            var widgetType = widget.tagName.toLowerCase();
            
            if (widgetType === 'yb-connector') {
              if (widgets.has(widget.fromWidget) &&
                  widgets.has(widget.viaWidget) &&
                  widgets.has(widget.toWidget)) {
                
                var newConnector = self.createConnector({
                  from: oldToNewNodeWidgetMap.get(widget.fromWidget),
                  via:  oldToNewNodeWidgetMap.get(widget.viaWidget),
                  to:   oldToNewNodeWidgetMap.get(widget.toWidget),
                });
                newWidgets.push(newConnector);
              }
            }
          });
          
          return newWidgets;
        },
        revealNodeWidgetTriples: function(nodeWidgets) {
          var self = this;
          
          var nodeIdsToWidgets = new Map();
          nodeWidgets.forEach(function(nodeWidget) {
            var nodeIdKey = self.node_id.toMapKey(self.node_id.fromHex(nodeWidget.nodeId));
            if (nodeIdsToWidgets.has(nodeIdKey)) {
              nodeIdsToWidgets.get(nodeIdKey).add(nodeWidget);
            } else {
              nodeIdsToWidgets.set(nodeIdKey, new Set([nodeWidget]));
            }
          });
          
          var nodeWidgetTriples = [];
          
          self.client.web.getLinks().forEach(function(link) {
            if (nodeIdsToWidgets.has(self.node_id.toMapKey(link.from)) &&
                nodeIdsToWidgets.has(self.node_id.toMapKey(link.via)) &&
                nodeIdsToWidgets.has(self.node_id.toMapKey(link.to))) {
              
              var nodeWidgetsFrom = nodeIdsToWidgets.get(self.node_id.toMapKey(link.from));
              var nodeWidgetsVia  = nodeIdsToWidgets.get(self.node_id.toMapKey(link.via));
              var nodeWidgetsTo   = nodeIdsToWidgets.get(self.node_id.toMapKey(link.to));
              
              nodeWidgetsFrom.forEach(function(nodeWidgetFrom) {
                nodeWidgetsVia.forEach(function(nodeWidgetVia) {
                  nodeWidgetsTo.forEach(function(nodeWidgetTo) {
                    
                    nodeWidgetTriples.push({
                      from: nodeWidgetFrom,
                      via:  nodeWidgetVia,
                      to:   nodeWidgetTo,
                    });
                  });
                });
              });
              
            }
          });
          
          return nodeWidgetTriples;
        },
        revealLinksBetweenNodeWidgets: function(nodeWidgets, activate) {
        
          var self = this;
          
          var delay = 0.0;
          
          self.client.web.getLinks().forEach(function(link) {
            var result = self.makeConnectorsForLink(link, {active: activate}, nodeWidgets);
            
            if (result.connectors.length) {
            
              result.newConnectors.forEach(function(connector) {
                var animation = self.highlightConnector(connector, {color: '#2FB51E', fadeOut: !activate, delay: delay});
                if (!activate) {
                  animation.then(
                    function() {
                      self.removeWidget(connector);
                    },
                    function() { }
                  );
                }
              });
              
              result.existingConnectors.forEach(function(connector) {
                if (!connector.active) {
                  self.activateConnector(connector);
                  var animation = self.highlightConnector(connector, {color: '#2FB51E', fadeOut: !activate, delay: delay});
                  if (!activate) {
                    animation.then(
                      function() {
                        self.removeWidget(connector);
                      },
                      function() { }
                    );
                  }
                }
              });
              
              delay += 150;
            }
          });
        },
        _setupNodeWidgetMenu: function(nodeWidget) {
          var self = this;
          
          nodeWidget.addEventListener('contextMenu', function(event) {
            if (!self.hasOperation()) {
              self.openSelectionMenu(event.detail);
            }
          });
        },
        createConnector: function(nodeWidgets, options) {
        
          var self = this;
        
          var connector = document.createElement('yb-connector');
          
          options = options || {};
          
          connector.active = ('active' in options) ? options.active : true;
          
          if (connector.active) {
            self.activeConnectors.add(connector);
          } else {
            connector.classList.add('inactive');
          }
          
          connector.fromWidget = nodeWidgets.from;
          connector.viaWidget  = nodeWidgets.via;
          connector.toWidget   = nodeWidgets.to;
         
          nodeWidgets.from.connectorsFrom.add(connector);
          nodeWidgets.via.connectorsVia.add(connector);
          nodeWidgets.to.connectorsTo.add(connector);
          
          var linkKey = self.node_id.linkToKey({
            from: self.node_id.fromHex(nodeWidgets.from.nodeId),
            via:  self.node_id.fromHex(nodeWidgets.via.nodeId),
            to:   self.node_id.fromHex(nodeWidgets.to.nodeId),
          });
          if (self.linksToConnectors.has(linkKey)) {
            self.linksToConnectors.get(linkKey).add(connector);
          } else {
            self.linksToConnectors.set(linkKey, new Set([connector]));
          }
          
          var nodeWidgetsLinkKey = self.node_id.linkToKey({
            from: nodeWidgets.from.widgetId,
            via:  nodeWidgets.via.widgetId,
            to:   nodeWidgets.to.widgetId,
          });
          self.nodeWidgetsToConnectors.set(nodeWidgetsLinkKey, connector);
          
          if (!self.connectorsFrom.has(nodeWidgets.from)) {
            self.connectorsFrom.set(nodeWidgets.from, [connector]);
          } else {
            self.connectorsFrom.get(nodeWidgets.from).push(connector);
          }
          
          if (!self.connectorsVia.has(nodeWidgets.via)) {
            self.connectorsVia.set(nodeWidgets.via, [connector]);
          } else {
            self.connectorsVia.get(nodeWidgets.via).push(connector);
          }
          
          if (!self.connectorsTo.has(nodeWidgets.to)) {
            self.connectorsTo.set(nodeWidgets.to, [connector]);
          } else {
            self.connectorsTo.get(nodeWidgets.to).push(connector);
          }
          
          var fromCenter = self.getWidgetCenter(nodeWidgets.from);
          var viaCenter  = self.getWidgetCenter(nodeWidgets.via);
          var toCenter   = self.getWidgetCenter(nodeWidgets.to);
          
          connector.set('fromPos', {
            x: fromCenter.x + self.viewMargin,
            y: fromCenter.y + self.viewMargin,
          });
          connector.set('viaPos', {
            x: viaCenter.x + self.viewMargin,
            y: viaCenter.y + self.viewMargin,
          });
          connector.set('toPos', {
            x: toCenter.x + self.viewMargin,
            y: toCenter.y + self.viewMargin,
          });
          
          self._setupConnectorHighlight(connector);
          self._setupConnectorMenu(connector);
          
          self.attachWidget(connector);
          
          return connector;
        },
        _setupConnectorHighlight: function(connector) {
          var self = this;
          connector.addEventListener('mouseover', function(event) {
            self.bringConnectorToFront(connector);
          });
        },
        _setupConnectorMenu: function(connector) {
          var self = this;
          connector.addEventListener('contextMenu', function(event) {
            self.openSelectionMenu(event.detail);
          });
        },
        activateConnector: function(connector, activate) {
          
          if (typeof activate === 'undefined') {
            activate = true;
          }
        
          if (activate && !connector.active) {
            connector.active = true;
            this.activeConnectors.add(connector);
            connector.classList.remove('inactive');
            if (connector.highlightAnimation) {
              console.log('cancelling connector highlight animation due to activation');
              connector.highlightAnimation.cancel();
              connector.highlightAnimation = null;
            }
          } else if (!activate && connector.active) {
            connector.active = false;
            this.activeConnectors.delete(connector);
            connector.classList.add('inactive');
            if (connector.highlightAnimation) {
              console.log('cancelling connector highlight animation due to deactivation');
              connector.highlightAnimation.cancel();
              connector.highlightAnimation = null;
            }
          }
        },
        updateConnectorsForNodeWidget: function(nodeWidget) {
          var self = this;
          
          var nodeCenter = self.getWidgetCenter(nodeWidget);
          
          if (self.connectorsFrom.has(nodeWidget)) {
            var connectorsFrom = self.connectorsFrom.get(nodeWidget);
            connectorsFrom.forEach(function(connector) {
              connector.set('fromPos', {
                x: nodeCenter.x + self.viewMargin,
                y: nodeCenter.y + self.viewMargin,
              });
            });
          }
          if (self.connectorsVia.has(nodeWidget)) {
            var connectorsVia = self.connectorsVia.get(nodeWidget);
            connectorsVia.forEach(function(connector) {
              connector.set('viaPos', {
                x: nodeCenter.x + self.viewMargin,
                y: nodeCenter.y + self.viewMargin,
              });
            });
          }
          if (self.connectorsTo.has(nodeWidget)) {
            var connectorsTo = self.connectorsTo.get(nodeWidget);
            connectorsTo.forEach(function(connector) {
              connector.set('toPos', {
                x: nodeCenter.x + self.viewMargin,
                y: nodeCenter.y + self.viewMargin,
              });
            })
          }
        },
        createSetWidget: function(filter) {
        
          var setWidget = document.createElement('yb-set');
          
          if (filter) {
            if (filter.from) {
              setWidget.set('from', this.node_id.toHex(filter.from));
            }
            if (filter.via) {
              setWidget.set('via', this.node_id.toHex(filter.via));
            }
            if (filter.to) {
              setWidget.set('to', this.node_id.toHex(filter.to));
            }
          }
          
          return setWidget;
        },
        removeSetWidget: function(setWidget) {
          var self = this;
          if (self.selectedSetWidgets.has(setWidget)) {
            self.selectedSetWidgets.delete(setWidget);
          }
          self.setWidgets.delete(setWidget);
          setWidget.dragdropAreas.forEach(function(dragdropArea) {
            self.dragdropAreas.delete(dragdropArea);
          });
          Polymer.dom(self.viewRoot).removeChild(setWidget);
        },
        _setupSetWidgetMenu: function(setWidget) {
          var self = this;
          setWidget.addEventListener('contextMenu', function(event) {
            if (event.detail.target === setWidget.widgetHandle) {
              if (!self.hasOperation()) {
                self.openSelectionMenu(event.detail);
              }
            }
          });
        },
        dragdropAreaAttached: function(event) {
          this.dragdropAreas.add(event.detail);
        },
        dragdropAreaDetached: function(event) {
          this.dragdropAreas.delete(event.detail);
        },
        openBackgroundMenu: function(position) {
          this.$.backgroundDropdown.style.position = 'absolute';
          this.$.backgroundDropdown.style.left = position.x + 'px';
          this.$.backgroundDropdown.style.top  = position.y + 'px';
          this.$.backgroundDropdown.style.display = 'block';
        },
        closeBackgroundMenu: function() {
          this.$.backgroundDropdown.style.display = 'none';
        },
        openSelectionMenu: function(event) {
          this.closeBackgroundMenu();
          
          var surfaceRect = this.getBoundingClientRect();
          this.$.selectionDropdown.style.position = 'absolute';
          this.$.selectionDropdown.style.left = (event.pageX - surfaceRect.left) + 'px';
          this.$.selectionDropdown.style.top  = (event.pageY - surfaceRect.top)  + 'px';
          this.$.selectionDropdown.style.display = 'block';
        },
        closeSelectionMenu() {
          this.$.selectionDropdown.style.display = 'none';
        },
        menuItem_CreateNode: function() {
          this.closeBackgroundMenu();
          var newWidget = this.createNodeWidget();
          this.attachWidget(newWidget, this.lastMenuPosition);
        },
        menuItem_CreateSet: function() {
          this.closeBackgroundMenu();
          var setWidget = this.createSetWidget();
          this.attachWidget(setWidget, this.lastMenuPosition);
        },
        menuItem_DeleteSelected: function() {
          this.closeSelectionMenu();
          this.deleteSelected();
        },
        menuItem_HideSelected: function() {
          this.closeSelectionMenu();
          this.hideSelectedWidgets();
        },
        menuItem_CopySelected: function() {
          this.closeSelectionMenu();
          var offset = 10;
          var newWidgets = this.duplicateWidgets(this.getSelectedWidgets(), offset);
          this.selectWidgets(newWidgets);
        },
        menuItem_RevealLinks: function() {
          this.closeSelectionMenu();
          this.revealLinksBetweenNodeWidgets(this.getSelectedWidgetsOfType('yb-node'), true);
        },
        menuItem_HideLinks: function() {
          var self = this;
          this.closeSelectionMenu();
          var connectors = self.getSelectedWidgetsOfType('yb-connector');
          self.getConnectorsBetweenNodeWidgets(self.getSelectedWidgetsOfType('yb-node')).forEach(function(connector) {
            connectors.add(connector);
          });
          connectors.forEach(function(connector) {
            self.hideConnector(connector);
          });
        },
      });
    })();
  </script>

</dom-module>