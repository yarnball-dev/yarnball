<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="set-styles.html">

<link rel="import" href="../selector/selector.html">
<link rel="import" href="../dragdrop-area/dragdrop-area.html">

<dom-module id="yb-set">

  <style include="set-styles"></style>

  <template>
    <div id="widgetHandle" class="widget-handle" on-mousedown="mousedown" on-mouseup="mouseup"></div>
    <div id="widgetBody" class="widget-body">
      <div class="header">
        <yb-selector id="fromSelector" node-id="{{from}}"></yb-selector>
        <span class="connector"></span>
        <yb-selector id="viaSelector"  node-id="{{via}}"> </yb-selector>
        <span class="connector"></span>
        <yb-selector id="toSelector"   node-id="{{to}}">  </yb-selector>
      </div>
      <yb-dragdrop-area id="setContent" on-nodes-dropped="nodesDropped" drop-on-hover>
      </yb-dragdrop-area>
    </div>
  </template>
  
  <script>
    (function() {
      'use strict';
      
      Polymer({
        is: 'yb-set',
        properties: {
          from: {
            type: String,
            notify: true,
            observer: 'refreshSet',
          },
          via: {
            type: String,
            notify: true,
            observer: 'refreshSet',
          },
          to: {
            type: String,
            notify: true,
            observer: 'refreshSet',
          },
          selected: {
            type: Boolean,
            value: false,
            observer: 'handleSelectedChanged',
          },
        },
        created: function() {
          this.widgets = new Set();
          this.dragdropAreas = new Set();
          this.nodeWidgetsInSet = new Map();
        },
        attached: function() {
          this.fire('widgetAttached', this);
        },
        listeners: {
          widgetAttached:  'widgetAttached',
          widgetDetached:  'widgetDetached',
          dragdropAreaAttached: 'dragdropAreaAttached',
          dragdropAreaDetached: 'dragdropAreaDetached',
        },
        ready: function() {
        
          var self = this;
          
          self.widgetHandle = self.$.widgetHandle;
          self.widgetBody   = self.$.widgetBody;
          
          require(['core/client', 'core/node_id'], function(client, node_id) {
            self.client  = client;
            self.node_id = node_id;
            self.refreshSet();
            self.onLinks = self.onLinks.bind(self);
            client.web.onLinks(self.onLinks);
          });
          
          self.$.setContent.dropRequestHandler = function(widgets) {
            return Array.from(widgets).filter(function(widget) {
              if (widget.tagName !== 'yb-node'.toUpperCase()) {
                return false;
              }
              
              return !Array.from(self.nodeWidgetsInSet.values()).some(function(existingNodeWidget) {
                return existingNodeWidget.nodeId === widget.nodeId;
              });
            });
          }
          
          self.$.setContent.addEventListener('widgetDragStart', function(event) {
            event.detail.widgets.forEach(function(nodeWidget) {
              nodeWidget.dragdropStartCursorPageX = event.detail.mouseEvent.pageX;
            });
          });
          
          self.$.setContent.addEventListener('widgetDrag', function(event) {
          
            var setContentRect = self.$.setContent.getBoundingClientRect();
          
            var widgetsDraggedOut = new Set(Array.from(event.detail.widgets).filter(function(nodeWidget) {
              var distanceDragged = Math.abs(event.detail.options.currentPosPage.x - nodeWidget.dragdropStartCursorPageX);
              return distanceDragged > (setContentRect.width / 2)
            }));
            
            if (widgetsDraggedOut.size > 0) {
            
              var nodeIds = Array.from(widgetsDraggedOut).map(function(nodeWidget) {
                return self.node_id.fromHex(nodeWidget.nodeId);
              });
              var detachedWidgets = Array.from(widgetsDraggedOut).map(function(nodeWidget) {
                nodeWidget.style.transform = null;
                nodeWidget.classList.remove('yb-set');
                return Polymer.dom(self.$.setContent).removeChild(nodeWidget);
              });
              self.$.setContent.fire('widgetsDraggedOut', {
                dragdropArea: self.$.setContent,
                oldWidgets: widgetsDraggedOut,
                detachedWidgets: detachedWidgets,
              });
              self.removeNodes(nodeIds);
            }
            
            event.detail.widgets.forEach(function(nodeWidget) {
              if (!widgetsDraggedOut.has(nodeWidget)) {
                nodeWidget.style.transform = 'translateX(' + (event.detail.options.currentPosPage.x - nodeWidget.dragdropStartCursorPageX) + 'px)';
              }
            });
          });
          
          self.$.setContent.addEventListener('widgetsDraggedIn', function(event) {
            var nodeIds = [];
            event.detail.widgets.forEach(function(nodeWidget) {
              self.attachNodeWidget(nodeWidget);
              nodeWidget.dragdropStartCursorPageX = event.detail.mouseEvent.pageX;
              nodeIds.push(self.node_id.fromHex(nodeWidget.nodeId));
            });
            self.addNodes(nodeIds);
          });
          
          self.$.setContent.addEventListener('widgetDragFinish', function(event) {
            event.detail.forEach(function(nodeWidget) {
              nodeWidget.style.transform = null;
//               nodeWidget.animate(
//                 [
//                   {transform: nodeWidget.style.transform},
//                   {transform: 'translateX(0px)'},
//                 ],
//                 {
//                   duration: 150,
//                   easing: 'ease-out',
//                 }
//               ).finished.then(function() {
//                 nodeWidget.style.transform = null;
//               });
            });
          });
        },
        detached: function() {
          this.client.web.removeLinksListener(this.onLinks);
        },
        onLinks: function(linksAdded, linksRemoved) {
          this.updateSet(linksAdded, linksRemoved);
        },
        widgetAttached: function(event) {
          this.widgets.add(event.detail);
        },
        widgetDetached: function(event) {
          this.widgets.delete(event.detail);
        },
        dragdropAreaAttached: function(event) {
          this.dragdropAreas.add(event.detail);
        },
        dragdropAreaDetached: function(event) {
          this.dragdropAreas.delete(event.detail);
        },
        mousedown: function(event) {
          if (event.target === this.widgetHandle && event.button === 0) {
            this.fire('selected',  {
              widget: this,
              mouseEvent: event,
            });
            this.fire('dragStart', event);
          }
        },
        mouseup: function(event) {
          if (event.button === 2) {
            this.fire('selected',    {
              widget: this,
              mouseEvent: event,
            });
            this.fire('contextMenu', event);
          }
        },
        handleSelectedChanged: function() {
          this.toggleClass('selected', this.selected);
        },
        isFilterValid: function() {
          return ((this.from ? 1:0) + (this.via ? 1:0) + (this.to ? 1:0)) === 2;
        },
        getFilter: function() {
          return {
            from: this.from ? this.node_id.fromHex(this.from) : null,
            via:  this.via  ? this.node_id.fromHex(this.via)  : null,
            to:   this.to   ? this.node_id.fromHex(this.to)   : null,
          }
        },
        filterLinks: function(links) {
          
          var self = this;
        
          if (!self.isFilterValid()) {
            return [];
          }
          return links.filter(function(link) {
            return (!self.from || self.node_id.toHex(link.from) === self.from) &&
                   (!self.via  || self.node_id.toHex(link.via)  === self.via) &&
                   (!self.to   || self.node_id.toHex(link.to)   === self.to);
          }).map(function(link) {
            if (!self.from) return link.from;
            if (!self.via)  return link.via;
            if (!self.to)   return link.to;
          });
        },
        refreshSet: function() {
          var self = this;
          
          self.$.setContent.set('enabled', self.isFilterValid());
          
          require(['core/client', 'core/node_id'], function(client, node_id) {
            self.node_id = node_id;
            var nodeIdKeys = new Set(self.filterLinks(client.web.getLinks()).map(function(nodeId) {
              return self.node_id.toMapKey(nodeId);
            }));
            self.nodeWidgetsInSet.forEach(function(nodeWidget, nodeIdKey) {
              if (!nodeIdKeys.has(nodeIdKey)) {
                self.removeNodeWidget(self.node_id.fromMapKey(nodeIdKey));
              }
            });
            nodeIdKeys.forEach(function(nodeIdKey) {
              if (!self.nodeWidgetsInSet.has(nodeIdKey)) {
                self.addNodeWidget(self.node_id.fromMapKey(nodeIdKey));
              }
            });
          });
        },
        updateSet: function(linksAdded, linksRemoved) {
        
          var self = this;
          
          self.filterLinks(linksAdded).forEach(function(nodeId) {
            if (!self.nodeWidgetsInSet.has(self.node_id.toMapKey(nodeId))) {
              self.addNodeWidget(nodeId);
            }
          });
          
          self.filterLinks(linksRemoved).forEach(function(nodeId) {
            self.removeNodeWidget(nodeId);
          });
        },
        addNodes: function(nodeIds) {
          var self = this;
          if (self.isFilterValid()) {
            var links = Array.from(nodeIds).map(function(nodeId) {
              return {
                from: self.from ? self.node_id.fromHex(self.from) : nodeId,
                via:  self.via  ? self.node_id.fromHex(self.via)  : nodeId,
                to:   self.to   ? self.node_id.fromHex(self.to)   : nodeId,
              }
            });
            self.client.addLinks(links);
          }
        },
        removeNodes: function(nodeIds) {
          var self = this;
          if (self.isFilterValid()) {
            var links = Array.from(nodeIds).map(function(nodeId) {
              return {
                from: self.from ? self.node_id.fromHex(self.from) : nodeId,
                via:  self.via  ? self.node_id.fromHex(self.via)  : nodeId,
                to:   self.to   ? self.node_id.fromHex(self.to)   : nodeId,
              }
            });
            self.client.removeLinks(links);
          }
        },
        addNodeWidget: function(nodeId) {
          var nodeWidget = document.createElement('yb-node');
          nodeWidget.nodeId = this.node_id.toHex(nodeId);
          Polymer.dom(this.$.setContent).appendChild(nodeWidget);
          this.nodeWidgetsInSet.set(this.node_id.toMapKey(nodeId), nodeWidget);
        },
        attachNodeWidget: function(nodeWidget) {
          nodeWidget.style.position = null;
          Polymer.dom(this.$.setContent).appendChild(nodeWidget);
          this.nodeWidgetsInSet.set(this.node_id.toMapKey(this.node_id.fromHex(nodeWidget.nodeId)), nodeWidget);
        },
        removeNodeWidget: function(nodeId) {
          var nodeWidget = this.nodeWidgetsInSet.get(this.node_id.toMapKey(nodeId));
          this.widgets.delete(nodeWidget);
          this.nodeWidgetsInSet.delete(this.node_id.toMapKey(nodeId));
          Polymer.dom(this.$.setContent).removeChild(nodeWidget);
        },
        nodesDropped: function(event) {
          var self = this;
          if (((self.from ? 1:0) + (self.via ? 1:0) + (self.to ? 1:0)) !== 2) {
            return;
          }
          var nodeWidgets = event.detail;
          require(['core/client', 'core/node_id'], function(client, node_id) {
            var links = Array.from(nodeWidgets).map(function(nodeWidget) {
              if (!self.from) {
                return {
                  from: node_id.fromHex(nodeWidget.nodeId),
                  via:  node_id.fromHex(self.via),
                  to:   node_id.fromHex(self.to),
                }
              } else if (!self.via) {
                return {
                  from: node_id.fromHex(self.from),
                  via:  node_id.fromHex(nodeWidget.nodeId),
                  to:   node_id.fromHex(self.to),
                }
              } else if (!self.to) {
                return {
                  from: node_id.fromHex(self.from),
                  via:  node_id.fromHex(self.via),
                  to:   node_id.fromHex(nodeWidget.nodeId),
                }
              }
            });
            client.addLinks(links);
          });
        },
      });
    })();
  </script>

</dom-module>